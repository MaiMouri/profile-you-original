package contorllers

import (
	"fmt"
	"net/http"
	"os"
	"sync"
	"time"

	gen "profileyou/api/ImageGenerator"
	"profileyou/api/service"
	"profileyou/api/usecase"
	"profileyou/api/utils/errors"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v4"
	_ "github.com/golang-jwt/jwt/v4"
	"golang.org/x/crypto/bcrypt"

	// "gorm.io/driver/sqlite"
	"profileyou/api/LoCred"
)

type keywordController struct {
	keywordUseCase usecase.KeywordUseCase
	loginService   service.LoginService
	signupService  service.SignupService
	jWtService     service.JWTService
}

// likes to Usecase by "ku"
func NewKeywordController(ku usecase.KeywordUseCase) keywordController {
	return keywordController{
		keywordUseCase: ku,
	}

}

func (ku *keywordController) GetAllKeywordsGin(c *gin.Context) {

	keywords, err := ku.keywordUseCase.GetKeywords()
	if err != nil {
		fmt.Println(err)
		apiErr := errors.NewBadRequestError("Get all Bad Request")
		c.IndentedJSON(apiErr.Status, apiErr)
		return
	}
	type ResultDataField struct {
		KeywordId   string
		Word        string
		Description string
		ImageUrl    string
	}
	var data []ResultDataField
	for _, keyword := range keywords {
		keywordId := string(keyword.GetKeywordId())
		word := string(keyword.GetWord())
		description := string(keyword.GetDescription())
		imageUrl := string(keyword.GetImageUrl())
		data = append(data, ResultDataField{KeywordId: keywordId, Word: word, Description: description, ImageUrl: imageUrl})
	}
	// c.HTML(200, "index.html", gin.H{"keywords": data})
	c.IndentedJSON(http.StatusOK, data)
}

func (ku *keywordController) GetKeyword(c *gin.Context) {
	id := c.Param("id")
	fmt.Printf("Get Keyword...param id: %v\n", id)
	keyword, err := ku.keywordUseCase.GetKeyword(id)
	fmt.Printf("keyword id: %v\n", keyword)
	if err != nil {
		fmt.Println(err)
		apiErr := errors.NotFoundError("Tried to find the record but Not found")
		c.IndentedJSON(apiErr.Status, apiErr)
		return
	}

	type ResultDataField struct {
		KeywordId   string
		Word        string
		Description string
		ImageUrl    string
	}

	data := ResultDataField{
		KeywordId:   string(keyword.GetKeywordId()),
		Word:        string(keyword.GetWord()),
		Description: string(keyword.GetDescription()),
		ImageUrl:    string(keyword.GetImageUrl()),
	}
	c.IndentedJSON(http.StatusOK, data)

}

func (ku *keywordController) Index(c *gin.Context) {
	keywords, err := ku.keywordUseCase.GetKeywords()
	// fmt.Printf("keywords :%v\n", keywords)
	if err != nil {
		fmt.Println(err)
		apiErr := errors.NewBadRequestError("Index Bad Request")
		c.IndentedJSON(apiErr.Status, apiErr)
		return
	}
	// 20221213 - Deleted prior to implement ResultDataField struct
	// c.IndentedJSON(http.StatusOK, keywords)

	type ResultDataField struct {
		KeywordId   string
		Word        string
		Description string
		ImageUrl    string
	}
	var data []ResultDataField
	for _, keyword := range keywords {
		keywordId := string(keyword.GetKeywordId())
		word := string(keyword.GetWord())
		description := string(keyword.GetDescription())
		imageUrl := string(keyword.GetImageUrl())
		data = append(data, ResultDataField{KeywordId: keywordId, Word: word, Description: description, ImageUrl: imageUrl})
	}
	c.HTML(200, "index.html", gin.H{"keywords": data})
	// c.IndentedJSON(http.StatusOK, data)
}

func (ku *keywordController) DetailKeyword(c *gin.Context, id string) {

	// id := c.Param("id")
	keyword, err := ku.keywordUseCase.GetKeyword(id)
	if err != nil {
		fmt.Println(err)
		apiErr := errors.NotFoundError("Not found")
		c.IndentedJSON(apiErr.Status, apiErr)
		return
	}

	type ResultDataField struct {
		KeywordId   string
		Word        string
		Description string
		ImageUrl    string
	}

	data := ResultDataField{KeywordId: string(keyword.GetKeywordId()), Word: string(keyword.GetWord()), Description: string(keyword.GetDescription()), ImageUrl: string(keyword.GetImageUrl())}
	c.IndentedJSON(http.StatusOK, data)
}

func (ku *keywordController) CreateKeyword(c *gin.Context) {
	type RequestDataField struct {
		Word        string `json:"Word" binding:"required"`
		Description string `json:"Description"`
		ImageUrl    string `json:"ImageUrl"`
		KeywordId   string `json:"KeywordId"`
	}

	var json RequestDataField

	if err := c.ShouldBindJSON(&json); err != nil {
		fmt.Printf("Error: %v\n", err)
		apiErr := errors.NewBadRequestError("Bad request on binding json")
		c.IndentedJSON(apiErr.Status, apiErr)
		return
	}

	word := json.Word
	description := ""
	imageUrl := ""
	fmt.Printf("Receive a post: %s\n", word)

	// Wordを元にイメージを作成
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		result := gen.ImageGenerator(word)
		fmt.Printf("Image Datas generated by api: %v\n", result[0].Url)
		imageUrl = result[0].Url
		imageUrl = gen.Cloudinary(imageUrl)
		wg.Done()
	}()
	wg.Wait()

	// WordとイメージURLをデータベースにSave
	err := ku.keywordUseCase.CreateKeyword(word, description, imageUrl)
	if err != nil {
		fmt.Println(err)
		apiErr := errors.InternalSeverError("Server Error when posting")
		c.IndentedJSON(apiErr.Status, apiErr)
		return
	}

	// Get a last record to send a info of the keyword
	wg.Add(1)
	go func() {
		keyword, err := ku.keywordUseCase.GetLastKeyword()
		if err != nil {
			fmt.Println(err)
			apiErr := errors.NotFoundError("Not found")
			c.IndentedJSON(apiErr.Status, apiErr)
			return
		}
		fmt.Printf("Generated %v\n", keyword.GetKeywordId())

		data := RequestDataField{KeywordId: string(keyword.GetKeywordId()), Word: string(keyword.GetWord()), Description: string(keyword.GetDescription()), ImageUrl: string(keyword.GetImageUrl())}
		c.IndentedJSON(http.StatusOK, data)
		wg.Done()
	}()
	wg.Wait()

}

func (ku *keywordController) UpdateKeyword(c *gin.Context) {
	type RequestDataField struct {
		KeywordId   string `json:"KeywordId" binding:"required"`
		Word        string `json:"Word" binding:"required"`
		Description string `json:"Description"`
		ImageUrl    string `json:"ImageUrl"`
	}

	var json RequestDataField

	if err := c.ShouldBindJSON(&json); err != nil {
		fmt.Println(err)
		apiErr := errors.NewBadRequestError("Bad request")
		c.IndentedJSON(apiErr.Status, apiErr)
		return
	}

	id := json.KeywordId
	word := json.Word
	description := json.Description
	imageUrl := json.ImageUrl

	fmt.Printf("Updating a keyword id: %v", id)
	keyword, err := ku.keywordUseCase.GetKeyword(id)
	if err != nil {
		fmt.Println(err)
		apiErr := errors.NotFoundError("Not found")
		c.IndentedJSON(apiErr.Status, apiErr)
		return
	}

	err = ku.keywordUseCase.UpdateKeyword(id, word, description, imageUrl)
	if err != nil {
		fmt.Println(err)
		apiErr := errors.InternalSeverError("Server Error")
		c.IndentedJSON(apiErr.Status, apiErr)
		return
	}
	data := RequestDataField{KeywordId: string(keyword.GetKeywordId()), Word: string(keyword.GetWord()), Description: string(keyword.GetDescription()), ImageUrl: string(keyword.GetImageUrl())}

	c.IndentedJSON(http.StatusOK, data)
}

func (ku *keywordController) DeleteKeyword(c *gin.Context) {
	type RequestDataField struct {
		KeywordId string `json:"KeywordId" binding:"required"`
	}
	var json RequestDataField

	if err := c.ShouldBindJSON(&json); err != nil {
		fmt.Println(err)
		apiErr := errors.NewBadRequestError("Bad Request")
		c.IndentedJSON(apiErr.Status, apiErr)
		return
	}

	keyword_id := json.KeywordId

	err := ku.keywordUseCase.DeleteKeyword(keyword_id)
	if err != nil {
		fmt.Println(err)
		apiErr := errors.InternalSeverError("Server Error")
		c.IndentedJSON(apiErr.Status, apiErr)
		return
	}
	fmt.Printf("Delete json %v\n", json)
	// c.IndentedJSON(http.StatusOK, gin.H{"data": keyword_id})
	c.IndentedJSON(http.StatusOK, json)

}

func (ku *keywordController) Authenticate(ctx *gin.Context) {

	fmt.Println("LOGIN: ")
	token := ku.Login(ctx)
	fmt.Printf("Token: %v\n", token)
	if token != "" {
		ctx.JSON(http.StatusOK, gin.H{
			"token": token,
		})
	} else {
		ctx.JSON(http.StatusUnauthorized, nil)
	}

}

func (ku *keywordController) Login(ctx *gin.Context) string {

	var credential LoCred.LoginCredentials
	fmt.Println("LoginController login cunf run")
	err := ctx.ShouldBindJSON(&credential)
	if err != nil {
		return ""
	}

	user, err := ku.keywordUseCase.GetUserForAuth(credential.Email)
	if err != nil {
		fmt.Println(err)
		apiErr := errors.NewBadRequestError("Bad Request")
		ctx.IndentedJSON(apiErr.Status, apiErr)
		return ""
	}

	fmt.Println(user.Password, credential.Password)

	err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(credential.Password))
	if err != nil {
		fmt.Println(err.Error())
		ctx.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid email or password",
		})
		return ""
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"sub": user.ID,
		"exp": time.Now().Add(time.Hour * 24 * 30).Unix(),
	})

	//encoded string
	t, err := token.SignedString([]byte(os.Getenv("SECRET")))
	if err != nil {
		panic(err)
	}
	fmt.Printf("token : %v\n", token)
	return t

}

// func (ku *keywordController) Authenticate(c *gin.Context) {
// 	// read json payload
// 	// var requestPayload struct {
// 	// 	Email    string `json:"email"`
// 	// 	Password string `json:"password"`
// 	// }

// 	// err := readJSON(w, r, &requestPayload)
// 	// if err != nil {
// 	// 	ku.errorJSON(w, err, http.StatusBadRequest)
// 	// 	return
// 	// }

// 	// // validate user against database
// 	// user, err := ku.DB.GetUserByEmail(requestPayload.Email)
// 	// if err != nil {
// 	// 	ku.errorJSON(w, errors.New("invalid credentials"), http.StatusBadRequest)
// 	// 	return
// 	// }

// 	// // check password
// 	// valid, err := user.PasswordMatches(requestPayload.Password)
// 	// if err != nil || !valid {
// 	// 	ku.errorJSON(w, errors.New("invalid credentials"), http.StatusBadRequest)
// 	// 	return
// 	// }

// 	// create a jwt user
// 	u := auth.JwtUser{
// 		ID:        1,
// 		FirstName: "Admin",
// 		LastName:  "User",
// 	}
// 	// u := jwtUser{
// 	// 	ID:        user.ID,
// 	// 	FirstName: user.FirstName,
// 	// 	LastName:  user.LastName,
// 	// }

// 	// // generate tokens
// 	tokens, err := ku.auth.GenerateTokenPair(&u)
// 	if err != nil {
// 		apiErr := errors.NewBadRequestError("Bad request")
// 		c.IndentedJSON(apiErr.Status, apiErr)
// 		return
// 	}
// 	log.Println(tokens.Token)
// 	// refreshCookie := ku.auth.GetRefreshCookie(tokens.RefreshToken)
// 	// http.SetCookie(w, refreshCookie)

// 	c.IndentedJSON(http.StatusOK, gin.H{"data": tokens})
// }
